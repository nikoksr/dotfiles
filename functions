# ~/.functions


##############################
#
# COMPRESSION
#
##############################


# Multithreaded compression via tar and pigz
# @param $1 - file or directory to compress
function compress() {
    # Check parameter
    if [ ! -n "$1" ]; then
        echo "Error: You have to specify a file or folder to compress"
        echo "Syntax: compress <file>"
        return 1
    fi

    # Execute compression
    tar cf - "$1" | pigz --best > "$1".tar.gz
}

# Decompression via tar and pigz
# @param $1 - compressed input
function decompress() {
    # Check parameter
    if [ ! -n "$1" ]; then
        echo "Error: You have to specify a file or folder to compress"
        echo "Syntax: decompress <file>"
        return 1
    fi

    # Execute decompression
    pigz -dc "$1" | tar xf -
}


##############################
#
# DOWNLOAD
#
##############################


# Downloading a file via Aria2c
# @param $1 - destination
# @param $2 - url to download
function dwnld-file() {
    # Check parameter
    if [ ! -n "$1" ] || [ ! -n "$2" ]; then
        echo "Error: Missing parameter"
        echo "Syntax: dwnld-file <url> <destination>"
        return 1
    fi

    # Execute download via aria2
    aria2c --file-allocation=none -c -x 10 -s 10 -d "$1" "$2"
}


##############################
#
# FZF
#
##############################


# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
f() {
  local files
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0 --preview '[[ $(file --mime {}) =~ binary ]] && echo {} is a binary file || (highlight -O ansi -l {} || cat {}) 2> /dev/null | head -500' --color dark))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

# fglog - git commit browser
fglog() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --header "Press CTRL-S to toggle sort" \
      --preview "echo {} | grep -o '[a-f0-9]\{7\}' | head -1 |
                 xargs -I % sh -c 'git show --color=always % | head -$LINES'" \
      --bind "enter:execute:echo {} | grep -o '[a-f0-9]\{7\}' | head -1 |
              xargs -I % sh -c 'vim fugitive://\$(git rev-parse --show-toplevel)/.git//% < /dev/tty'"
}


##############################
#
# DOTFILES
#
##############################


cp-dotfiles() {
  local df_path="/home/niko/dev/github/dotfiles/"

  if [ -z "$df_path" ]; then
      echo "Error: No path was provided."
      return
  fi

  echo "Copying files..."
  cpr -q ~/.aliases "${df_path}aliases"
  cpr -q ~/.functions "${df_path}functions"
  cpr -q ~/.gitconfig "${df_path}gitconfig"
  cpr -q ~/.ycm_extra_conf.py "${df_path}vim/ycm_extra_conf.py"
  cpr -q ~/.vimrc "${df_path}vim/vimrc"
  cpr -q ~/.Xresources "${df_path}Xresources"
  cpr -q ~/.zshrc "${df_path}zshrc"
  cpr -q ~/.zprofile "${df_path}zprofile"
  cpr -q ~/.config/compton.conf "${df_path}"
  cpr -q ~/.config/mpd/mpd.conf "${df_path}mpd.conf"

  echo "Copying folders..."
  cpr -rq ~/.vim/ftplugin "${df_path}vim/"
  cpr -rq ~/.config/i3 "${df_path}"
  cpr -rq ~/.config/polybar "${df_path}"
  cpr -rq ~/.config/rofi "${df_path}"
  cpr -rq ~/.config/dunst "${df_path}"
  cpr -rq ~/.config/termite "${df_path}"
  cpr -rq ~/.config/redshift "${df_path}"
  cpr -rq ~/dev/.templates/ "${df_path}templates"
  cpr -rq ~/.ncmpcpp/ "${df_path}ncmpcpp"

  echo "Done..."
}


#####################################################
#
# CREATE PROJECT
#
# Create an empty folder structure for dev projects
#
# @param $1 project-path/name
# @param $2 language
#
#####################################################


function create-project() {
    # Check parameter count
    if [ ! -n "$1" ] || [ ! -n "$2" ]; then
        echo "> Error: Missing parameter."
        echo "> Syntax: create-project <language> <projectname>"
        return 1
    fi

    # Check if directory already exists
    if [ -d "$2" ]; then
        echo "> Error: Directory already exists."
        return 2
    fi

    project="$2"

    # Check if language is valid
    langs=("c" "cpp" "c++" "cc" "python" "py" "go" "golang" "php" "js" "javascript" "ts" "typescript" "html" "css" "web")
    lang=""
    lang_found=0

    for l in "${langs[@]}"; do
        if [ "$l" = "$1" ]; then
            lang_found=1
            lang="$1"
            break
        fi
    done

    if [ $lang_found -eq 0 ]; then
        echo "> Error: You have to specify a valid language."
        echo "         Currently supported languages: ${langs[*]}"
        return 3
    fi

    # Create main project folder and cd into it
    echo "> Creating project folder..."
    mkdir -p "$project"
    cd "$project"

    # Create Readme and .gitignore
    echo "> Creating ReadMe and gitignore..."

    # ReadMe
    touch README.md
    echo "# $project" >> README.md

    # .gitignore
    echo .vscode/ > .gitignore

    # Create subfolders
    echo "> Creating subfolders..."

    # File to open in editor is language specific
    file_to_open=""

    # C and CPP specific
    if [ "$lang" = "c" ] || [ "$lang" = "cpp" ] || [ "$lang" = "c++" ] || [ "$lang" = "cc" ]; then

        # Unify language
        lang="cpp"

        mkdir -p build/
        mkdir -p build/debug/
        mkdir -p build/release/
        mkdir -p doc/
        mkdir -p include/"$project"/
        mkdir -p lib/
        mkdir -p src/
        mkdir -p test/

        # Copy vscode template folder for build and debug support
        echo "> Copying templates..."
        cp -r ~/dev/.templates/vscode-cpp .vscode

        # Create language specific template files
        cp ~/dev/.templates/main.cpp src/
        cp ~/dev/.templates/CMakeLists-cpp.txt CMakeLists.txt

        # Replace project-name in CMakesLists with the actual project name
        echo "> Applying project-name in CMakeLists..."
        sed -i -e "s/PROJECT-NAME/$project/g" CMakeLists.txt

        echo "build/" >> .gitignore

        file_to_open="src/main.cpp"

    # Web App
    elif [ "$lang" = "php" ] || [ "$lang" = "js" ] || [ "$lang" = "javascript" ] ||
            [ "$lang" = "ts" ] || [ "$lang" = "typescript" ] ||
            [ "$lang" = "html" ] || [ "$lang" = "css" ] || [ "$lang" = "web" ]; then
        mkdir -p public_html/css/
        mkdir -p public_html/img/content/
        mkdir -p public_html/img/layout/
        mkdir -p public_html/js/
        mkdir -p resources/library/
        mkdir -p resources/templates/

        # Copy config.php template
        echo "> Copying templates..."
        cp ~/dev/.templates/index.php public_html/
        cp ~/dev/.templates/config.php resources/

        file_to_open="public_html/index.php"

    # Python
    elif [ "$lang" = "python" ] || [ "$lang" = "py" ]; then

        lang="py"

        # Create subfolders
        mkdir -p "${project}/"
        mkdir -p doc/
        mkdir -p tests/
        cp -r ~/dev/.templates/vscode-py .vscode

        # Create virtualenv
        echo "> Creating virtualenv..."
        virtualenv --quiet .env
        echo .env/ >> .gitignore
        source .env/bin/activate

        # Python packages
        echo "> Installing python packages..."
        pip install --quiet pylint pep8 black pytest pytest-xdist

        # Create files
        cp ~/dev/.templates/__main__.py "${project}/__main__.py"
        cp ~/dev/.templates/template.py "${project}/${project}.py"
        touch "${project}/__init__.py"
        touch tests/__init__.py

        file_to_open="${project}/__main__.py"

    # Go
    elif [ "$lang" = "golang" ] || [ "$lang" = "go" ]; then

        lang="go"

        # Create subfolders
        mkdir -p "cmd/${project}/"
        mkdir -p "internal/app/${project}/"
        mkdir -p internal/pkg/
        mkdir -p configs/
        mkdir -p scripts/
        mkdir -p build/package/
        mkdir -p build/ci/
        mkdir -p test/
        mkdir -p docs/
        mkdir -p vendor/

        # cp -r ~/dev/.templates/vscode-py .vscode

        # Create files
        cp ~/dev/.templates/main.go "cmd/${project}/"
        touch "internal/app/${project}/${project}.go"

        file_to_open="cmd/${project}/main.go"
    fi

    # Git init, add and commit project
    echo "> Initializing git-repo..."
    git init . >/dev/null
    added_remote=0
    remote_name=""

    # Ask if user wants to add a git-remote
    while true; do
        echo -n "> Add git-remote? [y/N] "
        read yn

        # Evaluate input
        if [ ! -n "$yn" ] || [ "$yn" = "N" ] || [ "$yn" = "n" ]; then
            break
        elif [ "$yn" = "Y" ] || [ "$yn" = "y" ]; then

            # Read and validate remote-name
            echo -n "> Remote-name: "
            read remote_name

            if [ -z "$remote_name" -o "$remote_name" = " " ]; then
                echo "> Remote-name can't be empty..."
                return 4
            fi

            # Read and validate remote-url
            echo -n "> Remote-URL: "
            read remote_url

            if [ -z "$remote_url" -o "$remote_url" = " " ]; then
                echo "> Remote-URL can't be empty..."
                return 5
            fi

            # Append .git if missing
            if [[ ! $remote_url =~ ^.*\.git$ ]]; then
                remote_url="${remote_url}.git"
            fi

            # Add remote
            git remote add "$remote_name" "$remote_url" >/dev/null
            added_remote=1
        else
            echo "> Invalid input..."
            continue
        fi
        break
    done

    # Git add and commit
    git add . >/dev/null
    git commit -m "Create project $1" >/dev/null
    git tag v0.1 -m "Version v0.1" >/dev/null
    git checkout --quiet -b develop >/dev/null

    # Push if remote was added
    if [ $added_remote -eq 1 ]; then
        git push --quiet "$remote_name" master >/dev/null
        git push --quiet -u "$remote_name" develop >/dev/null
    fi

    # Send success message
    echo "> Done..."

    # Ask if project-folder should be opened in vscode
    while true; do
        echo -n "> Open project in vscode? [Y/n] "
        read yn

        # Evaluate input
        if [ ! -n "$yn" ] || [ "$yn" = "Y" ] || [ "$yn" = "y" ]; then
            code -n . -g "$file_to_open":1
        elif [ "$yn" != "N" ] && [ "$yn" != "n" ]; then
            continue
        fi
        break
    done
}


#####################################################
#
# BORG BACKUP
#
#####################################################


### Remote

# Mounten eines Remote-Borg-Backups.
# @param $1 Name des zu mountenden Remote-Archivs
# @param $2 Mount Pfad
function borg-mount-backup() {
    # Check parameter
    if [ ! -n "$1" ] || [ ! -n "$2" ]; then
        echo "Error: Missing parameter"
        echo "Syntax: borg-mount-backup <repo-name> <mount-path>"
        return 1
    fi

    # Execute borg mount
    borg mount borg@192.168.10.250:/betty/vault/backups/$HOST::"$1" "$2"
}


# Extrahieren eines Remote-Borg-Backups.
# @param $1 Name des zu mountenden Remote-Archivs
# Optional: @param $2 Unterordner des Archivs
function borg-extract-backup() {
    # Check parameter
    if [ ! -n "$1" ] && [ ! -n "$2" ]; then
        echo "Error: Missing parameter"
        echo "Syntax: borg-extract-backup <repo-name> [Optional: archive-folder]"
        return 1
    fi

    # Execute borg extract
    if [ -n "$1" ] && [ -n "$2" ]; then
        borg extract borg@192.168.10.250:/betty/vault/backups/$HOST::"$1" "$2"
    else
        borg extract borg@192.168.10.250:/betty/vault/backups/$HOST::"$1"
    fi
}


### USB

# Mounten eines Remote-Borg-Backups.
# @param $1 Name des zu mountenden Remote-Archivs
# @param $2 Mount Pfad
function borg-mount-backup() {
    # Check parameter
    if [ ! -n "$1" ] || [ ! -n "$2" ]; then
        echo "Error: Missing parameter"
        echo "Syntax: borg-mount-backup <repo-name> <mount-path>"
        return 1
    fi

    # Execute borg mount
    borg mount borg@192.168.10.250:/betty/vault/backups/$HOST::"$1" "$2"
}


# Extrahieren eines Remote-Borg-Backups.
# @param $1 Name des zu mountenden Remote-Archivs
# Optional: @param $2 Unterordner des Archivs
function borg-extract-backup() {
    # Check parameter
    if [ ! -n "$1" ] && [ ! -n "$2" ]; then
        echo "Error: Missing parameter"
        echo "Syntax: borg-extract-backup <repo-name> [Optional: archive-folder]"
        return 1
    fi

    # Execute borg extract
    if [ -n "$1" ] && [ -n "$2" ]; then
        borg extract borg@192.168.10.250:/betty/vault/backups/$HOST::"$1" "$2"
    else
        borg extract borg@192.168.10.250:/betty/vault/backups/$HOST::"$1"
    fi
}


#####################################################
#
# PYTHON VIRUAL ENV
#
#####################################################

